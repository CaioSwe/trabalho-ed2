#ifndef _GRAPH__
#define _GRAPH__

#include <stdbool.h>
#include "lista.h"

/*
Um Grafo direcionado  G e' constituido por um conjunto de vertices V e 
um conjunto de arestas E, denotado por G=(V,E). 

Pode-se associar um dado a arestas e a vertices de G.
A cada vertice e' associado um nome.

Existem tambem operacoes que possibilitam percorrer o grafo,
invocando funcoes quando arestas do grafo 
sao "descobertas", podendo, inclusive, interromper o percurso.

Este modulo faz parte de um trabalho de Estrutura de Dados do 
curso de Ciencia da Computacao da Universidade Estadual de Londrina.
E' expressamente proibido o uso de ferramentas de IA para a sua implementacao.
A documentacao deste modulo deve ser melhorada.
*/

typedef void* Graph;
typedef int Node;
typedef void* Edge;
typedef void* Info;

/*
  Invocado quando uma aresta é "descoberta"/"percorrida"/"classificada". 
  Tambem informa os tempos de descoberta e finalizacao
 */
bool (*procEdge)(Graph g, Edge e, int td, int tf, void* extra); 

/*
  Invocado quando percurso e' recomecado
 */
bool (*dfsRestarted)(Graph g, void* extra);

/*
    Cria um grafo com, no maximo, n vertices.
 */
Graph createGraph(int n);

/*
    Retorna numero maximo de vertices que grafo g pode conter.
 */
int getMaxNodes(Graph g);

/*
    Retorna numero total de vertices adicionados ao grafo g.
 */
int getTotalNodes(Graph g);

/*
    Adiciona um novo vértice ao grafo g com o nome "nome" e um valor info.
 */
Node addNode(Graph g, const char* nome, Info info);

/*
    Retorna nó cujo de nome é "nome". 
 */
Node getNode(Graph g, const char* nome);

/*
    Retorna o valor do tipo Info armazenado no nó especificado em node.
 */
Info getNodeInfo(Graph g, Node node);

/*
    Retorna o nome do nó especificado.
 */
char *getNodeName(Graph g, Node node);

/*
    Modifica a informação armazenada no nó especificado pela informação de info.
 */
void setNodeInfo(Graph g, Node node, Info info);

/*
    Adiciona uma aresta entre o nó from e o nó to, com informação info.
 */
Edge addEdge(Graph g, Node from, Node to, Info info);

/*
    Retorna a aresta entre o nó from e o nó to.
 */
Edge getEdge(Graph g, Node from, Node to);

/*

 */
Node getFromNode(Graph g, Edge e);
  
/*

 */  
Node getToNode(Graph g, Edge e);

/*

 */
Info getEdgeInfo(Graph g, Edge e);

/*
    Modifica a informação armazenada na aresta e.
 */
void setEdgeInfo(Graph g, Edge e, Info info);

/*
    Exclui a aresta e.
 */
void removeEdge(Graph g, Edge e);

/*
    Retorna um valor true caso os nós from e to forem adjacentes (próximos), e false caso o contrário.
 */
bool isAdjacent(Graph g, Node from, Node to);

/* 
   Adiciona à lista "nosAdjacentes" os nós adjacentes à "node".
 */
void adjacentNodes(Graph g, Node node, Lista* nosAdjacentes);

/*
   Adiciona à lista "arestaAdjacentes" as arestas (x,y), tal que,
   x == node.
 */
void adjacentEdges(Graph g, Node node, Lista* arestasAdjacentes);

/*
   Insere na lista "nomesNodes" os nomes atribuidos aos nós do grafo g.
 */
void  getNodeNames(Graph g, Lista* nomesNodes);

/*
   Insere na lista "arestas", as arestas do grafo g.
 */
void getEdges(Graph g, Lista* arestas);

/*
   Faz percurso em profundidade sobre  g, a partir do no' node, classificando 
   as arestas do grafo, invocando a respectiva funcao.
      A busca em profundidade, eventualmente, pode produzir uma floresta.
   newTree e' invocada sempre que o percurso for retomado.
 */  
//bool dfs(Graph g, Node node, procEdge treeEdge, forwardEdge, returnEdge, crossEdge, newTree, void *extra);

/*
   Percorre o grafo g em largura, a partir do no' node. discoverNode e' usada
   para a aresta (x,y) usada para "descobrir" o y.
 */
//bool bfs(Graph g, Node node, discoverNode, void *extra);

/*
   Destroi o grafo g.
 */
void killDG(Graph g);

#endif